默认网元A，为A端
1.INIT 来自网元A
	（1）MASTER处理，同时初始化一个SLAVE，把INIT交给SLAVE，等待SLAVE交付INIT ACK。
	（2）SLAVE发送INIT给网元B,进入COOKIE WAITE状态。
2.INTT ACK 来自网元B
	（1）SLAVE处理，同时检查MASTER是否在等待INIT ACK，如果是交付给MATSTER，否则建立失败。然后等待MASTER交付COOKIE ACK。
	（2）MASTER发送INTT ACK发送给给网元A。
3.COOKIE ECHO 来自网元A
	（1）MASTER处理，建立相应的偶联控制块，同时检查SLAVE是否在等待COOKIE ECHO，是交付给SLAVE，否则建立失败退出。等待SLAVE交付COOKIE ACK。
	（2）SLAVE发送COOKIE ECHO发送给给网元B。
4.COOKIE ACK来自网元B
	（1）SLAVE处理，建立相应的偶联控制块，同时检查MASTER是否在等待COOKIE ACK，是交付给MASTER，否则报错退出。
	（2）MAESTER处理，同时发送给网元A。

----------------------------- 辅助控制结构MS_Association-----------------------------
typedef struct MS_ASSOCIATION
{
    /** The current ID of this association,
        it is used as a key to find a association in the list, */
    unsigned int ms_assocId;
    /** the local port number of this association. */
    unsigned short localPort;
    /** the remote port number of this association. */
    unsigned short remotePort;
    /** number of destination networks (paths) */
    short noOfNetworks;
    /** array of destination addresses */
    union sockunion *destinationAddresses;
    /** association type(MASTER or SLAVE)*/
    int type;
    /** recv ring*/
    void *recv_ring;
    void *ms_assoc;
    /** ms state（等待INIT ACK(M初始)，等待COOKIE ECHO(S)，等待COOKIE ACK(M), Working(MS), Init by master(S初始))*/
    unsigned ms_state;
    gboolean deleted;
    /** marks an association for deletion */
}MS_Association;
队列如何标识一个MASTER和SLAVE：
 1.（local_port, remote_port, remote_ip, ass_type）;
 2.ms_assocId

----------------------------- 逻辑改动1-----------------------------
SCTP Instance只使用local port作唯一标识；
SCTP Instance使用使用local port作为key查找时，不存在需要立刻新建一个，因为要处理所有的sctp
----------------------------- 逻辑改动2-----------------------------
1.收到一个INIT
（1）做必要检查后，创建master association（等待INIT ACK）、slave association(Init by master)的控制结构，分别放入master队列和slave队列。
此时master association作为作为网元A的服务端，需要回一个INIT ACK。
注意：
a.master association的remotePort=src_port, localPort=dest_port destinationAddresses=src_addr localAddresses=dest_addr
b.slave association的remotePort=dest_port, localPort=src_port destinationAddresses=dest_addr localAddresses=src_addr
（2）slave association作为作为网元B的客户端，需要如何向网元B发送INIT？
INIT从何而来？直接使用现有的INIT。怎么发？直接ring，不行，超时重发没有。
参考test_tool作为客户端发起偶联的过程：
a.创建偶联控制块：
/**
 *  establish an Association
 *  This function allocates memory for a new association.
 *  For the active sideof an association, this function is called when ULP calls Associate（主动端由ULP直接调用）
 *  For the passive side this function is called when a valid cookie message is received.（被动端SCTP control被动调用）
 *  It also creates all the modules path management, bundling and SCTP-control.
 *  The rest of the modules are created with mdi_initAssociation.
 *  The created association is put into the list of associations.
 *
 *  @param SCTP_InstanceName    identifier for an SCTP instance (if there are more)
 *  @param  local_port          src port (which this association listens to)
 *  @param  remote_port         destination port (peers source port)
 *  @param   tagLocal           randomly generated tag belonging to this association
 *  @param  primaryDestinitionAddress   index of the primary address
 *  @param  noOfDestinationAddresses    number of addresses the peer has
 *  @param  destinationAddressList      pointer to the array of peer's addresses
 *  @return 0 for success, else 1 for failure
 */
unsigned short
mdi_newAssociation(void*  sInstance,
                   unsigned short local_port,
                   unsigned short remote_port,
                   unsigned int tagLocal,
                   short primaryDestinitionAddress,
                   short noOfDestinationAddresses,
                   union sockunion *destinationAddressList)
修改：
unsigned short
mdi_newAssociationEx(void*  sInstance,/*slave association的localPort在链表中查找 */
                   unsigned short local_port,/*slave association的localPort*/
                   unsigned short remote_port,/*slave association的remotePort*/
                   unsigned int tagLocal,/*?*/
                   short primaryDestinitionAddress,/*?*/
                   short noOfDestinationAddresses,/*slave association的noOfNetworks*/
                   union sockunion *destinationAddressList/*slave association的destinationAddresses*/
                   MS_Association *slave_assoc)/*pointer to slave , used to shutdown*/
完成工作：创建偶联控制块
b.初始化偶联，启动偶联
void scu_associate(unsigned short noOfOutStreams,
                   unsigned short noOfInStreams,
                   union sockunion* destinationList,
                   unsigned int numDestAddresses,
                   gboolean withPRSCTP)
修改：？
完成工作：发送INIT、启动计时器T1-init timer、进入COOKIE-WAIT状态
（3）同时修改对应slave association状态为等待COOKIE ECHO，表示（丢失问题？）。
注意：此时slave association的remotePort、noOfNetworks、destinationAddresses并未初始化，因为目前未得到A网元的任何信息（IP、端口）。
2.收到一个INTT ACK，初始化slave association的remotePort、noOfNetworks、destinationAddresses。
根据接收ring，选择发送ring，发送给网元B
2.MASTER收到COOKIE ECHO需要入队偶联队列（new A）
3.SLAEVER收到COOKIE ACK需要入队偶联队列(new B)