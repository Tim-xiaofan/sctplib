默认网元A，为A端
1.INIT 来自网元A
	（1）MASTER处理，同时初始化一个SLAVE，把INIT交给SLAVE，等待SLAVE交付INIT ACK。
	（2）SLAVE发送INIT给网元B,进入COOKIE WAITE状态。
2.INTT ACK 来自网元B
	（1）SLAVE处理，同时检查MASTER是否在等待INIT ACK，如果是交付给MATSTER，否则建立失败。然后等待MASTER交付COOKIE ACK。
	（2）MASTER发送INTT ACK发送给给网元A。
3.COOKIE ECHO 来自网元A
	（1）MASTER处理，建立相应的偶联控制块，同时检查SLAVE是否在等待COOKIE ECHO，是交付给SLAVE，否则建立失败退出。等待SLAVE交付COOKIE ACK。
	（2）SLAVE发送COOKIE ECHO发送给给网元B。
4.COOKIE ACK来自网元B
	（1）SLAVE处理，建立相应的偶联控制块，同时检查MASTER是否在等待COOKIE ACK，是交付给MASTER，否则报错退出。
	（2）MAESTER处理，同时发送给网元A。

----------------------------- 辅助控制结构MS_Association-----------------------------
/*slave 和 master同属于这个结构体*/
typedef struct MS_ASSOCIATION
{
    /** The current ID of this association,
        it is used as a key to find a association in the list, */
    unsigned int ms_assocId;
    /** the local port number of this association. */
    unsigned short localPort;
    /** the remote port number of this association. */
    unsigned short remotePort;
    /** number of destination networks (paths) */
    short noOfNetworks;
    /** array of destination addresses */
    union sockunion *destinationAddresses;
    /** association type(MASTER or SLAVE)*/
    int type;
    /** recv ring*/
    void *recv_ring;
    void *ms_assoc;
    /** ms state（等待得到INIT ACK(M初始)，等待得到COOKIE ECHO(S)，等待得到COOKIE ACK(M), Working(MS), Init by master(S初始))
        slave: NEED_INIT  NEED_COOKIE_ECHO HAS_ASSOCIATION
        master: NEED_INIT_ACK NEED_COOKIE HAS_ASSOCIATION*/
    unsigned ms_state;
    gboolean deleted;
    /** marks an association for deletion */
}MS_Association;
队列如何标识一个MASTER和SLAVE：
 1.（local_port, remote_port, remote_ip, ass_type）;
 2.ms_assocId

----------------------------- 逻辑改动1-----------------------------
SCTP Instance只使用local port作唯一标识；
SCTP Instance使用使用local port作为key查找时，不存在需要立刻新建一个，因为要处理所有的sctp
----------------------------- 逻辑改动2-----------------------------
1.收到INIT
（1）做必要检查后，创建master、slave的控制结构，分别放入master队列和slave队列。
a.master:remotePort=src_port, localPort=dest_port, destinationAddresses=src_addr INIT的option部分地址, localAddresses=dest_addr
b.slave:remotePort=dest_port, localPort=src_port, destinationAddresses=dest_addr, localAddresses=src_addr + INIT的option部分地址
c.设置master的状态为NEED_INIT_ACK, slave状态为NEED_INIT
其中src_port、dest_port来自SCTP common head
（2）以slave为基础，创建偶联控制块Association B，作为网元B的客户端（即active端），向网元B发送INIT，发起偶联。
a.使用新编写的函数，创建偶联控制块Aassociation B：
设置本地IP、本地端口、远端IP端口、远端端口、初始化path management、bundling和SCTP-control
/**
 *  Internal function only called by mdi_associatex 
 *  establish an Association but bot scan local addresses 
 *  This function allocates memory for a new association.
 *  It also creates all the modules path management, bundling and SCTP-control.
 *  The rest of the modules are created with mdi_initAssociation.
 *  The created association is put into the list of associations.
 *
 *  @param SCTP_InstanceName    identifier for an SCTP instance (if there are more)
 *  @param  local_port          src port (which this association listens to)
 *  @param  remote_port         destination port (peers source port)
 *  @param   tagLocal           randomly generated tag belonging to this association
 *  @param  primaryDestinitionAddress   index of the primary address
 *  @param  noOfDestinationAddresses    number of addresses the peer has
 *  @param  destinationAddressList      pointer to the array of peer's addresses
 *  @param  noOfLocalAddresses          number of addresses self has
 *  @param  localAddressList            pointer to the array of self's addresses
 *  @param  ms_assoc                    pointer to struct MS_Association that used when close Association
 *  @return 0 for success, else 1 for failure
 */
static unsigned short
newAssociation(void*  sInstance,
                   unsigned short local_port,
                   unsigned short remote_port,
                   unsigned int tagLocal,
                   short primaryDestinitionAddress,
                   short noOfDestinationAddresses,
                   union sockunion *destinationAddressList,
                   short noOfLocalAddresses,
                   union sockunion *localAddressList,
                   void ms_assoc)
b.使用新编写的函数，初始化偶联的其他模块:
发送INIT、保存INIT以备重发、启动计时器T1-init timer、更新偶联AssociationB状态为COOKIE-WAIT、更新slave状态为NEED_COOKIE_ECHO
/**
 * This function is called to initiate the setup an association.
 * The local tag and the initial TSN are randomly generated.
 * Together with the parameters of the function, they are used to create the init-message.
 * This data are also stored in a newly created association-record.
 *
 * @param noOfOutStreams        number of send streams.
 * @param noOfInStreams         number of receive streams.
 * @param destinationList       
 * @param numDestAddresses
 * @param withPRSCTP
 * @param initCID               the index of INIT provied（现成的INIT）
 */
void sci_associate(unsigned short noOfOutStreams,
                   unsigned short noOfInStreams,
                   union sockunion* destinationList,
                   unsigned int numDestAddresses,
                   gboolean withPRSCTP,
                   short initCID)

2.INTT ACK
（1）a.偶联控制块Association B根据自身状态处理；
（2）a.更新master association:localAddresses+=INIT ACK的option部分地址；
b.发送INIT ACK。INIT ACK是现成的，那要怎么发？（计时器、保存、超时重发等等）
2.MASTER收到COOKIE ECHO需要入队偶联队列（new A）
3.SLAEVER收到COOKIE ACK需要入队偶联队列(new B)